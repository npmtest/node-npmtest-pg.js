{"/home/travis/build/npmtest/node-npmtest-pg.js/test.js":"/* istanbul instrument in package npmtest_pg_js */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-pg.js/lib.npmtest_pg.js.js":"/* istanbul instrument in package npmtest_pg_js */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_pg_js = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_pg_js = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-pg.js/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-pg.js && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_pg_js */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_pg_js\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_pg_js.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_pg_js.rollup.js'] =\n            local.assetsDict['/assets.npmtest_pg_js.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_pg_js.__dirname + '/lib.npmtest_pg_js.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-pg.js/node_modules/pg.js/index.js":"module.exports = require('./lib')\n","/home/travis/build/npmtest/node-npmtest-pg.js/node_modules/pg.js/lib/index.js":"var EventEmitter = require('events').EventEmitter;\nvar util = require('util');\nvar Client = require(__dirname+'/client');\nvar defaults =  require(__dirname + '/defaults');\nvar pool = require(__dirname + '/pool');\nvar Connection = require(__dirname + '/connection');\n\nvar PG = function(clientConstructor) {\n  EventEmitter.call(this);\n  this.defaults = defaults;\n  this.Client = pool.Client = clientConstructor;\n  this.Query = this.Client.Query;\n  this.pools = pool;\n  this.Connection = Connection;\n  this.types = require('pg-types');\n};\n\nutil.inherits(PG, EventEmitter);\n\nPG.prototype.end = function() {\n  var self = this;\n  var keys = Object.keys(self.pools.all);\n  var count = keys.length;\n  if(count === 0) {\n    self.emit('end');\n  } else {\n    keys.forEach(function(key) {\n      var pool = self.pools.all[key];\n      delete self.pools.all[key];\n      pool.drain(function() {\n        pool.destroyAllNow(function() {\n          count--;\n          if(count === 0) {\n            self.emit('end');\n          }\n        });\n      });\n    });\n  }\n};\n\n\nPG.prototype.connect = function(config, callback) {\n  if(typeof config == \"function\") {\n    callback = config;\n    config = null;\n  }\n  var pool = this.pools.getOrCreate(config);\n  pool.connect(callback);\n  if(!pool.listeners('error').length) {\n    //propagate errors up to pg object\n    pool.on('error', this.emit.bind(this, 'error'));\n  }\n};\n\n// cancel the query runned by the given client\nPG.prototype.cancel = function(config, client, query) {\n  if(client.native) {\n    return client.cancel(query);\n  }\n  var c = config;\n  //allow for no config to be passed\n  if(typeof c === 'function') {\n    c = defaults;\n  }\n  var cancellingClient = new this.Client(c);\n  cancellingClient.cancel(client, query);\n};\n\nif(typeof process.env.NODE_PG_FORCE_NATIVE != 'undefined') {\n  module.exports = new PG(require('./native'));\n} else {\n  module.exports = new PG(Client);\n\n  //lazy require native module...the native module may not have installed\n  module.exports.__defineGetter__(\"native\", function() {\n    delete module.exports.native;\n    module.exports.native = new PG(require('./native'));\n    return module.exports.native;\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-pg.js/node_modules/pg.js/lib/client.js":"var crypto = require('crypto');\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('util');\nvar pgPass = require('pgpass');\nvar TypeOverrides = require('./type-overrides');\n\nvar ConnectionParameters = require(__dirname + '/connection-parameters');\nvar Query = require(__dirname + '/query');\nvar defaults = require(__dirname + '/defaults');\nvar Connection = require(__dirname + '/connection');\n\nvar Client = function(config) {\n  EventEmitter.call(this);\n\n  this.connectionParameters = new ConnectionParameters(config);\n  this.user = this.connectionParameters.user;\n  this.database = this.connectionParameters.database;\n  this.port = this.connectionParameters.port;\n  this.host = this.connectionParameters.host;\n  this.password = this.connectionParameters.password;\n\n  var c = config || {};\n\n  this._types = new TypeOverrides(c.types);\n\n  this.connection = c.connection || new Connection({\n    stream: c.stream,\n    ssl: this.connectionParameters.ssl\n  });\n  this.queryQueue = [];\n  this.binary = c.binary || defaults.binary;\n  this.encoding = 'utf8';\n  this.processID = null;\n  this.secretKey = null;\n  this.ssl = this.connectionParameters.ssl || false;\n};\n\nutil.inherits(Client, EventEmitter);\n\nClient.prototype.connect = function(callback) {\n  var self = this;\n  var con = this.connection;\n\n  if(this.host && this.host.indexOf('/') === 0) {\n    con.connect(this.host + '/.s.PGSQL.' + this.port);\n  } else {\n    con.connect(this.port, this.host);\n  }\n\n\n  //once connection is established send startup message\n  con.on('connect', function() {\n    if(self.ssl) {\n      con.requestSsl();\n    } else {\n      con.startup(self.getStartupConf());\n    }\n  });\n\n  con.on('sslconnect', function() {\n    con.startup(self.getStartupConf());\n  });\n\n  function checkPgPass(cb) {\n    return function(msg) {\n      if (null !== self.password) {\n        cb(msg);\n      } else {\n        pgPass(self.connectionParameters, function(pass){\n          if (undefined !== pass) {\n            self.connectionParameters.password = self.password = pass;\n          }\n          cb(msg);\n        });\n      }\n    };\n  }\n\n  //password request handling\n  con.on('authenticationCleartextPassword', checkPgPass(function() {\n    con.password(self.password);\n  }));\n\n  //password request handling\n  con.on('authenticationMD5Password', checkPgPass(function(msg) {\n    var inner = Client.md5(self.password + self.user);\n    var outer = Client.md5(inner + msg.salt.toString('binary'));\n    var md5password = \"md5\" + outer;\n    con.password(md5password);\n  }));\n\n  con.once('backendKeyData', function(msg) {\n    self.processID = msg.processID;\n    self.secretKey = msg.secretKey;\n  });\n\n  //hook up query handling events to connection\n  //after the connection initially becomes ready for queries\n  con.once('readyForQuery', function() {\n\n    //delegate rowDescription to active query\n    con.on('rowDescription', function(msg) {\n      self.activeQuery.handleRowDescription(msg);\n    });\n\n    //delegate dataRow to active query\n    con.on('dataRow', function(msg) {\n      self.activeQuery.handleDataRow(msg);\n    });\n\n    //delegate portalSuspended to active query\n    con.on('portalSuspended', function(msg) {\n      self.activeQuery.handlePortalSuspended(con);\n    });\n\n    //delegate commandComplete to active query\n    con.on('commandComplete', function(msg) {\n      self.activeQuery.handleCommandComplete(msg, con);\n    });\n\n    //if a prepared statement has a name and properly parses\n    //we track that its already been executed so we don't parse\n    //it again on the same client\n    con.on('parseComplete', function(msg) {\n      if(self.activeQuery.name) {\n        con.parsedStatements[self.activeQuery.name] = true;\n      }\n    });\n\n    con.on('copyInResponse', function(msg) {\n      self.activeQuery.handleCopyInResponse(self.connection);\n    });\n\n    con.on('copyData', function (msg) {\n      self.activeQuery.handleCopyData(msg, self.connection);\n    });\n\n    con.on('notification', function(msg) {\n      self.emit('notification', msg);\n    });\n\n    //process possible callback argument to Client#connect\n    if (callback) {\n      callback(null, self);\n      //remove callback for proper error handling\n      //after the connect event\n      callback = null;\n    }\n    self.emit('connect');\n  });\n\n  con.on('readyForQuery', function() {\n    var activeQuery = self.activeQuery;\n    self.activeQuery = null;\n    self.readyForQuery = true;\n    self._pulseQueryQueue();\n    if(activeQuery) {\n      activeQuery.handleReadyForQuery();\n    }\n  });\n\n  con.on('error', function(error) {\n    if(self.activeQuery) {\n      var activeQuery = self.activeQuery;\n      self.activeQuery = null;\n      return activeQuery.handleError(error, con);\n    }\n    if(!callback) {\n      return self.emit('error', error);\n    }\n    callback(error);\n    callback = null;\n  });\n\n  con.once('end', function() {\n    if ( callback ) {\n      // haven't received a connection message yet !\n      var err = new Error('Connection terminated');\n      callback(err);\n      callback = null;\n      return;\n    }\n    if(self.activeQuery) {\n      var disconnectError = new Error('Connection terminated');\n      self.activeQuery.handleError(disconnectError, con);\n      self.activeQuery = null;\n    }\n    self.emit('end');\n  });\n\n\n  con.on('notice', function(msg) {\n    self.emit('notice', msg);\n  });\n\n};\n\nClient.prototype.getStartupConf = function() {\n  var params = this.connectionParameters;\n\n  var data = {\n    user: params.user,\n    database: params.database\n  };\n\n  var appName = params.application_name || params.fallback_application_name;\n  if (appName) {\n    data.application_name = appName;\n  }\n\n  return data;\n};\n\nClient.prototype.cancel = function(client, query) {\n  if(client.activeQuery == query) {\n    var con = this.connection;\n\n    if(this.host && this.host.indexOf('/') === 0) {\n      con.connect(this.host + '/.s.PGSQL.' + this.port);\n    } else {\n      con.connect(this.port, this.host);\n    }\n\n    //once connection is established send cancel message\n    con.on('connect', function() {\n      con.cancel(client.processID, client.secretKey);\n    });\n  } else if(client.queryQueue.indexOf(query) != -1) {\n    client.queryQueue.splice(client.queryQueue.indexOf(query), 1);\n  }\n};\n\nClient.prototype.setTypeParser = function(oid, format, parseFn) {\n  return this._types.setTypeParser(oid, format, parseFn);\n};\n\nClient.prototype.getTypeParser = function(oid, format) {\n  return this._types.getTypeParser(oid, format);\n};\n\n// Ported from PostgreSQL 9.2.4 source code in src/interfaces/libpq/fe-exec.c\nClient.prototype.escapeIdentifier = function(str) {\n\n  var escaped = '\"';\n\n  for(var i = 0; i < str.length; i++) {\n    var c = str[i];\n    if(c === '\"') {\n      escaped += c + c;\n    } else {\n      escaped += c;\n    }\n  }\n\n  escaped += '\"';\n\n  return escaped;\n};\n\n// Ported from PostgreSQL 9.2.4 source code in src/interfaces/libpq/fe-exec.c\nClient.prototype.escapeLiteral = function(str) {\n\n  var hasBackslash = false;\n  var escaped = '\\'';\n\n  for(var i = 0; i < str.length; i++) {\n    var c = str[i];\n    if(c === '\\'') {\n      escaped += c + c;\n    } else if (c === '\\\\') {\n      escaped += c + c;\n      hasBackslash = true;\n    } else {\n      escaped += c;\n    }\n  }\n\n  escaped += '\\'';\n\n  if(hasBackslash === true) {\n    escaped = ' E' + escaped;\n  }\n\n  return escaped;\n};\n\nClient.prototype._pulseQueryQueue = function() {\n  if(this.readyForQuery===true) {\n    this.activeQuery = this.queryQueue.shift();\n    if(this.activeQuery) {\n      this.readyForQuery = false;\n      this.hasExecuted = true;\n      this.activeQuery.submit(this.connection);\n    } else if(this.hasExecuted) {\n      this.activeQuery = null;\n      this.emit('drain');\n    }\n  }\n};\n\nClient.prototype.copyFrom = function (text) {\n  throw new Error(\"For PostgreSQL COPY TO/COPY FROM support npm install pg-copy-streams\");\n};\n\nClient.prototype.copyTo = function (text) {\n  throw new Error(\"For PostgreSQL COPY TO/COPY FROM support npm install pg-copy-streams\");\n};\n\nClient.prototype.query = function(config, values, callback) {\n  //can take in strings, config object or query object\n  var query = (typeof config.submit == 'function') ? config :\n     new Query(config, values, callback);\n  if(this.binary && !query.binary) {\n    query.binary = true;\n  }\n  if(query._result) {\n    query._result._getTypeParser = this._types.getTypeParser.bind(this._types);\n  }\n\n  this.queryQueue.push(query);\n  this._pulseQueryQueue();\n  return query;\n};\n\nClient.prototype.end = function() {\n  this.connection.end();\n};\n\nClient.md5 = function(string) {\n  return crypto.createHash('md5').update(string).digest('hex');\n};\n\n// expose a Query constructor\nClient.Query = Query;\n\nmodule.exports = Client;\n","/home/travis/build/npmtest/node-npmtest-pg.js/node_modules/pg.js/lib/type-overrides.js":"var types = require('pg-types');\n\nfunction TypeOverrides(userTypes) {\n  this._types = userTypes || types;\n  this.text = {};\n  this.binary = {};\n}\n\nTypeOverrides.prototype.getOverrides = function(format) {\n  switch(format) {\n    case 'text': return this.text;\n    case 'binary': return this.binary;\n    default: return {};\n  }\n};\n\nTypeOverrides.prototype.setTypeParser = function(oid, format, parseFn) {\n  if(typeof format == 'function') {\n    parseFn = format;\n    format = 'text';\n  }\n  this.getOverrides(format)[oid] = parseFn;\n};\n\nTypeOverrides.prototype.getTypeParser = function(oid, format) {\n  format = format || 'text';\n  return this.getOverrides(format)[oid] || this._types.getTypeParser(oid, format);\n};\n\nmodule.exports = TypeOverrides;\n","/home/travis/build/npmtest/node-npmtest-pg.js/node_modules/pg.js/lib/connection-parameters.js":"var url = require('url');\nvar dns = require('dns');\n\nvar defaults = require(__dirname + '/defaults');\n\nvar val = function(key, config, envVar) {\n  if (envVar === undefined) {\n    envVar = process.env[ 'PG' + key.toUpperCase() ];\n  } else if (envVar === false) {\n    // do nothing ... use false\n  } else {\n    envVar = process.env[ envVar ];\n  }\n\n  return config[key] ||\n    envVar ||\n    defaults[key];\n};\n\n//parses a connection string\nvar parse = require('pg-connection-string').parse;\n\nvar useSsl = function() {\n  switch(process.env.PGSSLMODE) {\n  case \"disable\":\n    return false;\n  case \"prefer\":\n  case \"require\":\n  case \"verify-ca\":\n  case \"verify-full\":\n    return true;\n  }\n  return defaults.ssl;\n};\n\nvar ConnectionParameters = function(config) {\n  config = typeof config == 'string' ? parse(config) : (config || {});\n  this.user = val('user', config);\n  this.database = val('database', config);\n  this.port = parseInt(val('port', config), 10);\n  this.host = val('host', config);\n  this.password = val('password', config);\n  this.binary = val('binary', config);\n  this.ssl = config.ssl || useSsl();\n  this.client_encoding = val(\"client_encoding\", config);\n  //a domain socket begins with '/'\n  this.isDomainSocket = (!(this.host||'').indexOf('/'));\n\n  this.application_name = val('application_name', config, 'PGAPPNAME');\n  this.fallback_application_name = val('fallback_application_name', config, false);\n};\n\nvar add = function(params, config, paramName) {\n  var value = config[paramName];\n  if(value) {\n    params.push(paramName+\"='\"+value+\"'\");\n  }\n};\n\nConnectionParameters.prototype.getLibpqConnectionString = function(cb) {\n  var params = [];\n  add(params, this, 'user');\n  add(params, this, 'password');\n  add(params, this, 'port');\n  add(params, this, 'application_name');\n  add(params, this, 'fallback_application_name');\n\n  if(this.database) {\n    params.push(\"dbname='\" + this.database + \"'\");\n  }\n  if(this.host) {\n    params.push(\"host=\" + this.host);\n  }\n  if(this.isDomainSocket) {\n    return cb(null, params.join(' '));\n  }\n  if(this.client_encoding) {\n    params.push(\"client_encoding='\" + this.client_encoding + \"'\");\n  }\n  dns.lookup(this.host, function(err, address) {\n    if(err) return cb(err, null);\n    params.push(\"hostaddr=\" + address);\n    return cb(null, params.join(' '));\n  });\n};\n\nmodule.exports = ConnectionParameters;\n","/home/travis/build/npmtest/node-npmtest-pg.js/node_modules/pg.js/lib/defaults.js":"var defaults = module.exports = {\n  // database host defaults to localhost\n  host: 'localhost',\n\n  //database user's name\n  user: process.platform === 'win32' ? process.env.USERNAME : process.env.USER,\n\n  //name of database to connect\n  database: process.platform === 'win32' ? process.env.USERNAME : process.env.USER,\n\n  //database user's password\n  password: null,\n\n  //database port\n  port: 5432,\n\n  //number of rows to return at a time from a prepared statement's\n  //portal. 0 will return all rows at once\n  rows: 0,\n\n  // binary result mode\n  binary: false,\n\n  //Connection pool options - see https://github.com/coopernurse/node-pool\n  //number of connections to use in connection pool\n  //0 will disable connection pooling\n  poolSize: 10,\n\n  //max milliseconds a client can go unused before it is removed\n  //from the pool and destroyed\n  poolIdleTimeout: 30000,\n\n  //frequeny to check for idle clients within the client pool\n  reapIntervalMillis: 1000,\n\n  //pool log function / boolean\n  poolLog: false,\n\n  client_encoding: \"\",\n\n  ssl: false,\n\n  application_name : undefined,\n  fallback_application_name: undefined\n};\n\n//parse int8 so you can get your count values as actual numbers\nmodule.exports.__defineSetter__(\"parseInt8\", function(val) {\n  require('pg-types').setTypeParser(20, 'text', val ? parseInt : function(val) { return val; });\n});\n","/home/travis/build/npmtest/node-npmtest-pg.js/node_modules/pg.js/lib/query.js":"var EventEmitter = require('events').EventEmitter;\nvar util = require('util');\n\nvar Result = require(__dirname + '/result');\nvar utils = require(__dirname + '/utils');\n\nvar Query = function(config, values, callback) {\n  // use of \"new\" optional\n  if(!(this instanceof Query)) { return new Query(config, values, callback); }\n\n  config = utils.normalizeQueryConfig(config, values, callback);\n\n  this.text = config.text;\n  this.values = config.values;\n  this.rows = config.rows;\n  this.types = config.types;\n  this.name = config.name;\n  this.binary = config.binary;\n  this.stream = config.stream;\n  //use unique portal name each time\n  this.portal = config.portal || \"\";\n  this.callback = config.callback;\n  if(process.domain && config.callback) {\n    this.callback = process.domain.bind(config.callback);\n  }\n  this._result = new Result(config.rowMode, config.types);\n  this.isPreparedStatement = false;\n  this._canceledDueToError = false;\n  EventEmitter.call(this);\n};\n\nutil.inherits(Query, EventEmitter);\n\nQuery.prototype.requiresPreparation = function() {\n  //named queries must always be prepared\n  if(this.name) { return true; }\n  //always prepare if there are max number of rows expected per\n  //portal execution\n  if(this.rows) { return true; }\n  //don't prepare empty text queries\n  if(!this.text) { return false; }\n  //binary should be prepared to specify results should be in binary\n  //unless there are no parameters\n  if(this.binary && !this.values) { return false; }\n  //prepare if there are values\n  return (this.values || 0).length > 0;\n};\n\n\n//associates row metadata from the supplied\n//message with this query object\n//metadata used when parsing row results\nQuery.prototype.handleRowDescription = function(msg) {\n  this._result.addFields(msg.fields);\n};\n\nQuery.prototype.handleDataRow = function(msg) {\n  var row = this._result.parseRow(msg.fields);\n  this.emit('row', row, this._result);\n\n  //if there is a callback collect rows\n  if(this.callback) {\n    this._result.addRow(row);\n  }\n};\n\nQuery.prototype.handleCommandComplete = function(msg, con) {\n  this._result.addCommandComplete(msg);\n  //need to sync after each command complete of a prepared statement\n  if(this.isPreparedStatement) {\n    con.sync();\n  }\n};\n\nQuery.prototype.handleReadyForQuery = function() {\n  if(this._canceledDueToError) {\n    return this.handleError(this._canceledDueToError);\n  }\n  if(this.callback) {\n    this.callback(null, this._result);\n  }\n  this.emit('end', this._result);\n};\n\nQuery.prototype.handleError = function(err, connection) {\n  //need to sync after error during a prepared statement\n  if(this.isPreparedStatement) {\n    connection.sync();\n  }\n  if(this._canceledDueToError) {\n    err = this._canceledDueToError;\n    this._canceledDueToError = false;\n  }\n  //if callback supplied do not emit error event as uncaught error\n  //events will bubble up to node process\n  if(this.callback) {\n    return this.callback(err);\n  }\n  this.emit('error', err);\n};\n\nQuery.prototype.submit = function(connection) {\n  if(this.requiresPreparation()) {\n    this.prepare(connection);\n  } else {\n    connection.query(this.text);\n  }\n};\n\nQuery.prototype.hasBeenParsed = function(connection) {\n  return this.name && connection.parsedStatements[this.name];\n};\n\nQuery.prototype.handlePortalSuspended = function(connection) {\n  this._getRows(connection, this.rows);\n};\n\nQuery.prototype._getRows = function(connection, rows) {\n  connection.execute({\n    portal: this.portalName,\n    rows: rows\n  }, true);\n  connection.flush();\n};\n\nQuery.prototype.prepare = function(connection) {\n  var self = this;\n  //prepared statements need sync to be called after each command\n  //complete or when an error is encountered\n  this.isPreparedStatement = true;\n  //TODO refactor this poor encapsulation\n  if(!this.hasBeenParsed(connection)) {\n    connection.parse({\n      text: self.text,\n      name: self.name,\n      types: self.types\n    }, true);\n  }\n\n  //TODO is there some better way to prepare values for the database?\n  if(self.values) {\n    for(var i = 0, len = self.values.length; i < len; i++) {\n      self.values[i] = utils.prepareValue(self.values[i]);\n    }\n  }\n\n  //http://developer.postgresql.org/pgdocs/postgres/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY\n  connection.bind({\n    portal: self.portalName,\n    statement: self.name,\n    values: self.values,\n    binary: self.binary\n  }, true);\n\n  connection.describe({\n    type: 'P',\n    name: self.portalName || \"\"\n  }, true);\n\n  this._getRows(connection, this.rows);\n};\n\nQuery.prototype.handleCopyInResponse = function (connection) {\n  if(this.stream) this.stream.startStreamingToConnection(connection);\n  else connection.sendCopyFail('No source stream defined');\n};\n\nQuery.prototype.handleCopyData = function (msg, connection) {\n  var chunk = msg.chunk;\n  if(this.stream) {\n    this.stream.handleChunk(chunk);\n  }\n  //if there are no stream (for example when copy to query was sent by\n  //query method instead of copyTo) error will be handled\n  //on copyOutResponse event, so silently ignore this error here\n};\nmodule.exports = Query;\n","/home/travis/build/npmtest/node-npmtest-pg.js/node_modules/pg.js/lib/result.js":"var types = require('pg-types');\n\n//result object returned from query\n//in the 'end' event and also\n//passed as second argument to provided callback\nvar Result = function(rowMode) {\n  this.command = null;\n  this.rowCount = null;\n  this.oid = null;\n  this.rows = [];\n  this.fields = [];\n  this._parsers = [];\n  this.RowCtor = null;\n  this.rowAsArray = rowMode == \"array\";\n  if(this.rowAsArray) {\n    this.parseRow = this._parseRowAsArray;\n  }\n};\n\nvar matchRegexp = /([A-Za-z]+) ?(\\d+ )?(\\d+)?/;\n\n//adds a command complete message\nResult.prototype.addCommandComplete = function(msg) {\n  var match;\n  if(msg.text) {\n    //pure javascript\n    match = matchRegexp.exec(msg.text);\n  } else {\n    //native bindings\n    match = matchRegexp.exec(msg.command);\n  }\n  if(match) {\n    this.command = match[1];\n    //match 3 will only be existing on insert commands\n    if(match[3]) {\n      //msg.value is from native bindings\n      this.rowCount = parseInt(match[3] || msg.value, 10);\n      this.oid = parseInt(match[2], 10);\n    } else {\n      this.rowCount = parseInt(match[2], 10);\n    }\n  }\n};\n\nResult.prototype._parseRowAsArray = function(rowData) {\n  var row = [];\n  for(var i = 0, len = rowData.length; i < len; i++) {\n    var rawValue = rowData[i];\n    if(rawValue !== null) {\n      row.push(this._parsers[i](rawValue));\n    } else {\n      row.push(null);\n    }\n  }\n  return row;\n};\n\n//rowData is an array of text or binary values\n//this turns the row into a JavaScript object\nResult.prototype.parseRow = function(rowData) {\n  return new this.RowCtor(this._parsers, rowData);\n};\n\nResult.prototype.addRow = function(row) {\n  this.rows.push(row);\n};\n\nvar inlineParser = function(fieldName, i) {\n  return \"\\nthis['\" +\n    //fields containing single quotes will break\n    //the evaluated javascript unless they are escaped\n    //see https://github.com/brianc/node-postgres/issues/507\n    fieldName.replace(\"'\", \"\\\\'\") +\n    \"'] = \" +\n    \"rowData[\" + i + \"] == null ? null : parsers[\" + i + \"](rowData[\" + i + \"]);\";\n};\n\nResult.prototype.addFields = function(fieldDescriptions) {\n  //clears field definitions\n  //multiple query statements in 1 action can result in multiple sets\n  //of rowDescriptions...eg: 'select NOW(); select 1::int;'\n  //you need to reset the fields\n  if(this.fields.length) {\n    this.fields = [];\n    this._parsers = [];\n  }\n  var ctorBody = \"\";\n  for(var i = 0; i < fieldDescriptions.length; i++) {\n    var desc = fieldDescriptions[i];\n    this.fields.push(desc);\n    var parser = this._getTypeParser(desc.dataTypeID, desc.format || 'text');\n    this._parsers.push(parser);\n    //this is some craziness to compile the row result parsing\n    //results in ~60% speedup on large query result sets\n    ctorBody += inlineParser(desc.name, i);\n  }\n  if(!this.rowAsArray) {\n    this.RowCtor = Function(\"parsers\", \"rowData\", ctorBody);\n  }\n};\n\nResult.prototype._getTypeParser = types.getTypeParser;\n\nmodule.exports = Result;\n","/home/travis/build/npmtest/node-npmtest-pg.js/node_modules/pg.js/lib/utils.js":"\n// convert a JS array to a postgres array literal\n// uses comma separator so won't work for types like box that use\n// a different array separator.\nfunction arrayString(val) {\n  var result = '{';\n  for (var i = 0 ; i < val.length; i++) {\n    if(i > 0) {\n      result = result + ',';\n    }\n    if(val[i] === null || typeof val[i] === 'undefined') {\n      result = result + 'NULL';\n    }\n    else if(Array.isArray(val[i])) {\n      result = result + arrayString(val[i]);\n    }\n    else\n    {\n      result = result + JSON.stringify(prepareValue(val[i]));\n    }\n  }\n  result = result + '}';\n  return result;\n}\n\n//converts values from javascript types\n//to their 'raw' counterparts for use as a postgres parameter\n//note: you can override this function to provide your own conversion mechanism\n//for complex types, etc...\nvar prepareValue = function(val, seen) {\n  if (val instanceof Buffer) {\n    return val;\n  }\n  if(val instanceof Date) {\n    return dateToString(val);\n  }\n  if(Array.isArray(val)) {\n    return arrayString(val);\n  }\n  if(val === null || typeof val === 'undefined') {\n    return null;\n  }\n  if(typeof val === 'object') {\n    return prepareObject(val, seen);\n  }\n  return val.toString();\n};\n\nfunction prepareObject(val, seen) {\n  if(val.toPostgres && typeof val.toPostgres === 'function') {\n    seen = seen || [];\n    if (seen.indexOf(val) !== -1) {\n      throw new Error('circular reference detected while preparing \"' + val + '\" for query');\n    }\n    seen.push(val);\n\n    return prepareValue(val.toPostgres(prepareValue), seen);\n  }\n  return JSON.stringify(val);\n}\n\nfunction dateToString(date) {\n  function pad(number, digits) {\n    number = \"\"+number;\n    while(number.length < digits)\n      number = \"0\"+number;\n    return number;\n  }\n\n  var offset = -date.getTimezoneOffset();\n  var ret = pad(date.getFullYear(), 4) + '-' +\n    pad(date.getMonth() + 1, 2) + '-' +\n    pad(date.getDate(), 2) + 'T' +\n    pad(date.getHours(), 2) + ':' +\n    pad(date.getMinutes(), 2) + ':' +\n    pad(date.getSeconds(), 2) + '.' +\n    pad(date.getMilliseconds(), 3);\n\n  if(offset < 0) {\n    ret += \"-\";\n    offset *= -1;\n  }\n  else\n    ret += \"+\";\n\n  return ret + pad(Math.floor(offset/60), 2) + \":\" + pad(offset%60, 2);\n}\n\nfunction normalizeQueryConfig (config, values, callback) {\n  //can take in strings or config objects\n  config = (typeof(config) == 'string') ? { text: config } : config;\n  if(values) {\n    if(typeof values === 'function') {\n      config.callback = values;\n    } else {\n      config.values = values;\n    }\n  }\n  if(callback) {\n    config.callback = callback;\n  }\n  return config;\n}\n\nmodule.exports = {\n  prepareValue: prepareValue,\n  normalizeQueryConfig: normalizeQueryConfig\n};\n","/home/travis/build/npmtest/node-npmtest-pg.js/node_modules/pg.js/lib/connection.js":"var net = require('net');\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('util');\n\nvar Writer = require('buffer-writer');\nvar Reader = require('packet-reader');\n\nvar TEXT_MODE = 0;\nvar BINARY_MODE = 1;\nvar Connection = function(config) {\n  EventEmitter.call(this);\n  config = config || {};\n  this.stream = config.stream || new net.Stream();\n  this.lastBuffer = false;\n  this.lastOffset = 0;\n  this.buffer = null;\n  this.offset = null;\n  this.encoding = 'utf8';\n  this.parsedStatements = {};\n  this.writer = new Writer();\n  this.ssl = config.ssl || false;\n  this._ending = false;\n  this._mode = TEXT_MODE;\n  this._emitMessage = false;\n  this._reader = new Reader({\n    headerSize: 1,\n    lengthPadding: -4\n  });\n  var self = this;\n  this.on('newListener', function(eventName) {\n    if(eventName == 'message') {\n      self._emitMessage = true;\n    }\n  });\n};\n\nutil.inherits(Connection, EventEmitter);\n\nConnection.prototype.connect = function(port, host) {\n\n  if(this.stream.readyState === 'closed') {\n    this.stream.connect(port, host);\n  } else if(this.stream.readyState == 'open') {\n    this.emit('connect');\n  }\n\n  var self = this;\n\n  this.stream.on('connect', function() {\n    self.emit('connect');\n  });\n\n  this.stream.on('error', function(error) {\n    //don't raise ECONNRESET errors - they can & should be ignored\n    //during disconnect\n    if(self._ending && error.code == 'ECONNRESET') {\n      return;\n    }\n    self.emit('error', error);\n  });\n\n  this.stream.on('close', function() {\n    // NOTE: node-0.10 emits both 'end' and 'close'\n    //       for streams closed by the peer, while\n    //       node-0.8 only emits 'close'\n    self.emit('end');\n  });\n\n  if(!this.ssl) {\n    return this.attachListeners(this.stream);\n  }\n\n  this.stream.once('data', function(buffer) {\n    var responseCode = buffer.toString('utf8');\n    if(responseCode != 'S') {\n      return self.emit('error', new Error('The server does not support SSL connections'));\n    }\n    var tls = require('tls');\n    self.stream = tls.connect({\n      socket: self.stream,\n      servername: host,\n      rejectUnauthorized: self.ssl.rejectUnauthorized,\n      ca: self.ssl.ca,\n      pfx: self.ssl.pfx,\n      key: self.ssl.key,\n      passphrase: self.ssl.passphrase,\n      cert: self.ssl.cert,\n      NPNProtocols: self.ssl.NPNProtocols\n    });\n    self.attachListeners(self.stream);\n    self.emit('sslconnect');\n\n    self.stream.on('error', function(error){\n      self.emit('error', error);\n    });\n  });\n};\n\nConnection.prototype.attachListeners = function(stream) {\n  var self = this;\n  stream.on('data', function(buff) {\n    self._reader.addChunk(buff);\n    var packet = self._reader.read();\n    while(packet) {\n      var msg = self.parseMessage(packet);\n      if(self._emitMessage) {\n        self.emit('message', msg);\n      }\n      self.emit(msg.name, msg);\n      packet = self._reader.read();\n    }\n  });\n};\n\nConnection.prototype.requestSsl = function() {\n  this.checkSslResponse = true;\n\n  var bodyBuffer = this.writer\n    .addInt16(0x04D2)\n    .addInt16(0x162F).flush();\n\n  var length = bodyBuffer.length + 4;\n\n  var buffer = new Writer()\n    .addInt32(length)\n    .add(bodyBuffer)\n    .join();\n  this.stream.write(buffer);\n};\n\nConnection.prototype.startup = function(config) {\n  var writer = this.writer\n    .addInt16(3)\n    .addInt16(0)\n  ;\n\n  Object.keys(config).forEach(function(key){\n    var val = config[key];\n    writer.addCString(key).addCString(val);\n  });\n\n  writer.addCString('client_encoding').addCString(\"'utf-8'\");\n\n  var bodyBuffer = writer.addCString('').flush();\n  //this message is sent without a code\n\n  var length = bodyBuffer.length + 4;\n\n  var buffer = new Writer()\n    .addInt32(length)\n    .add(bodyBuffer)\n    .join();\n  this.stream.write(buffer);\n};\n\nConnection.prototype.cancel = function(processID, secretKey) {\n  var bodyBuffer = this.writer\n    .addInt16(1234)\n    .addInt16(5678)\n    .addInt32(processID)\n    .addInt32(secretKey)\n    .addCString('').flush();\n\n  var length = bodyBuffer.length + 4;\n\n  var buffer = new Writer()\n    .addInt32(length)\n    .add(bodyBuffer)\n    .join();\n  this.stream.write(buffer);\n};\n\nConnection.prototype.password = function(password) {\n  //0x70 = 'p'\n  this._send(0x70, this.writer.addCString(password));\n};\n\nConnection.prototype._send = function(code, more) {\n  if(!this.stream.writable) { return false; }\n  if(more === true) {\n    this.writer.addHeader(code);\n  } else {\n    return this.stream.write(this.writer.flush(code));\n  }\n};\n\nConnection.prototype.query = function(text) {\n  //0x51 = Q\n  this.stream.write(this.writer.addCString(text).flush(0x51));\n};\n\n//send parse message\n//\"more\" === true to buffer the message until flush() is called\nConnection.prototype.parse = function(query, more) {\n  //expect something like this:\n  // { name: 'queryName',\n  //   text: 'select * from blah',\n  //   types: ['int8', 'bool'] }\n\n  //normalize missing query names to allow for null\n  query.name = query.name || '';\n  //normalize null type array\n  query.types = query.types || [];\n  var len = query.types.length;\n  var buffer = this.writer\n    .addCString(query.name) //name of query\n    .addCString(query.text) //actual query text\n    .addInt16(len);\n  for(var i = 0; i < len; i++) {\n    buffer.addInt32(query.types[i]);\n  }\n\n  var code = 0x50;\n  this._send(code, more);\n};\n\n//send bind message\n//\"more\" === true to buffer the message until flush() is called\nConnection.prototype.bind = function(config, more) {\n  //normalize config\n  config = config || {};\n  config.portal = config.portal || '';\n  config.statement = config.statement || '';\n  config.binary = config.binary || false;\n  var values = config.values || [];\n  var len = values.length;\n  var useBinary = false;\n  for (var j = 0; j < len; j++)\n    useBinary |= values[j] instanceof Buffer;\n  var buffer = this.writer\n    .addCString(config.portal)\n    .addCString(config.statement);\n  if (!useBinary)\n    buffer.addInt16(0);\n  else {\n    buffer.addInt16(len);\n    for (j = 0; j < len; j++)\n      buffer.addInt16(values[j] instanceof Buffer);\n  }\n  buffer.addInt16(len);\n  for(var i = 0; i < len; i++) {\n    var val = values[i];\n    if(val === null || typeof val === \"undefined\") {\n      buffer.addInt32(-1);\n    } else if (val instanceof Buffer) {\n      buffer.addInt32(val.length);\n      buffer.add(val);\n    } else {\n      buffer.addInt32(Buffer.byteLength(val));\n      buffer.addString(val);\n    }\n  }\n\n  if(config.binary) {\n    buffer.addInt16(1); // format codes to use binary\n    buffer.addInt16(1);\n  }\n  else {\n    buffer.addInt16(0); // format codes to use text\n  }\n  //0x42 = 'B'\n  this._send(0x42, more);\n};\n\n//send execute message\n//\"more\" === true to buffer the message until flush() is called\nConnection.prototype.execute = function(config, more) {\n  config = config || {};\n  config.portal = config.portal || '';\n  config.rows = config.rows || '';\n  this.writer\n    .addCString(config.portal)\n    .addInt32(config.rows);\n\n  //0x45 = 'E'\n  this._send(0x45, more);\n};\n\nvar emptyBuffer = Buffer(0);\n\nConnection.prototype.flush = function() {\n  //0x48 = 'H'\n  this.writer.add(emptyBuffer);\n  this._send(0x48);\n};\n\nConnection.prototype.sync = function() {\n  //clear out any pending data in the writer\n  this.writer.flush(0);\n\n  this.writer.add(emptyBuffer);\n  this._ending = true;\n  this._send(0x53);\n};\n\nConnection.prototype.end = function() {\n  //0x58 = 'X'\n  this.writer.add(emptyBuffer);\n  this._ending = true;\n  this._send(0x58);\n};\n\nConnection.prototype.close = function(msg, more) {\n  this.writer.addCString(msg.type + (msg.name || ''));\n  this._send(0x43, more);\n};\n\nConnection.prototype.describe = function(msg, more) {\n  this.writer.addCString(msg.type + (msg.name || ''));\n  this._send(0x44, more);\n};\n\nConnection.prototype.sendCopyFromChunk = function (chunk) {\n  this.stream.write(this.writer.add(chunk).flush(0x64));\n};\n\nConnection.prototype.endCopyFrom = function () {\n  this.stream.write(this.writer.add(emptyBuffer).flush(0x63));\n};\n\nConnection.prototype.sendCopyFail = function (msg) {\n  //this.stream.write(this.writer.add(emptyBuffer).flush(0x66));\n  this.writer.addCString(msg);\n  this._send(0x66);\n};\n\nvar Message = function(name, length) {\n  this.name = name;\n  this.length = length;\n};\n\nConnection.prototype.parseMessage =  function(buffer) {\n\n  this.offset = 0;\n  var length = buffer.length + 4;\n  switch(this._reader.header)\n  {\n\n  case 0x52: //R\n    return this.parseR(buffer, length);\n\n  case 0x53: //S\n    return this.parseS(buffer, length);\n\n  case 0x4b: //K\n    return this.parseK(buffer, length);\n\n  case 0x43: //C\n    return this.parseC(buffer, length);\n\n  case 0x5a: //Z\n    return this.parseZ(buffer, length);\n\n  case 0x54: //T\n    return this.parseT(buffer, length);\n\n  case 0x44: //D\n    return this.parseD(buffer, length);\n\n  case 0x45: //E\n    return this.parseE(buffer, length);\n\n  case 0x4e: //N\n    return this.parseN(buffer, length);\n\n  case 0x31: //1\n    return new Message('parseComplete', length);\n\n  case 0x32: //2\n    return new Message('bindComplete', length);\n\n  case 0x33: //3\n    return new Message('closeComplete', length);\n\n  case 0x41: //A\n    return this.parseA(buffer, length);\n\n  case 0x6e: //n\n    return new Message('noData', length);\n\n  case 0x49: //I\n    return new Message('emptyQuery', length);\n\n  case 0x73: //s\n    return new Message('portalSuspended', length);\n\n  case 0x47: //G\n    return this.parseG(buffer, length);\n\n  case 0x48: //H\n    return this.parseH(buffer, length);\n\n  case 0x63: //c\n    return new Message('copyDone', length);\n\n  case 0x64: //d\n    return this.parsed(buffer, length);\n  }\n};\n\nConnection.prototype.parseR = function(buffer, length) {\n  var code = 0;\n  var msg = new Message('authenticationOk', length);\n  if(msg.length === 8) {\n    code = this.parseInt32(buffer);\n    if(code === 3) {\n      msg.name = 'authenticationCleartextPassword';\n    }\n    return msg;\n  }\n  if(msg.length === 12) {\n    code = this.parseInt32(buffer);\n    if(code === 5) { //md5 required\n      msg.name = 'authenticationMD5Password';\n      msg.salt = new Buffer(4);\n      buffer.copy(msg.salt, 0, this.offset, this.offset + 4);\n      this.offset += 4;\n      return msg;\n    }\n  }\n  throw new Error(\"Unknown authenticatinOk message type\" + util.inspect(msg));\n};\n\nConnection.prototype.parseS = function(buffer, length) {\n  var msg = new Message('parameterStatus', length);\n  msg.parameterName = this.parseCString(buffer);\n  msg.parameterValue = this.parseCString(buffer);\n  return msg;\n};\n\nConnection.prototype.parseK = function(buffer, length) {\n  var msg = new Message('backendKeyData', length);\n  msg.processID = this.parseInt32(buffer);\n  msg.secretKey = this.parseInt32(buffer);\n  return msg;\n};\n\nConnection.prototype.parseC = function(buffer, length) {\n  var msg = new Message('commandComplete', length);\n  msg.text = this.parseCString(buffer);\n  return msg;\n};\n\nConnection.prototype.parseZ = function(buffer, length) {\n  var msg = new Message('readyForQuery', length);\n  msg.name = 'readyForQuery';\n  msg.status = this.readString(buffer, 1);\n  return msg;\n};\n\nvar ROW_DESCRIPTION = 'rowDescription';\nConnection.prototype.parseT = function(buffer, length) {\n  var msg = new Message(ROW_DESCRIPTION, length);\n  msg.fieldCount = this.parseInt16(buffer);\n  var fields = [];\n  for(var i = 0; i < msg.fieldCount; i++){\n    fields.push(this.parseField(buffer));\n  }\n  msg.fields = fields;\n  return msg;\n};\n\nvar Field = function() {\n  this.name = null;\n  this.tableID = null;\n  this.columnID = null;\n  this.dataTypeID = null;\n  this.dataTypeSize = null;\n  this.dataTypeModifier = null;\n  this.format = null;\n};\n\nvar FORMAT_TEXT = 'text';\nvar FORMAT_BINARY = 'binary';\nConnection.prototype.parseField = function(buffer) {\n  var field = new Field();\n  field.name = this.parseCString(buffer);\n  field.tableID = this.parseInt32(buffer);\n  field.columnID = this.parseInt16(buffer);\n  field.dataTypeID = this.parseInt32(buffer);\n  field.dataTypeSize = this.parseInt16(buffer);\n  field.dataTypeModifier = this.parseInt32(buffer);\n  if(this.parseInt16(buffer) === TEXT_MODE) {\n    this._mode = TEXT_MODE;\n    field.format = FORMAT_TEXT;\n  } else {\n    this._mode = BINARY_MODE;\n    field.format = FORMAT_BINARY;\n  }\n  return field;\n};\n\nvar DATA_ROW = 'dataRow';\nvar DataRowMessage = function(length, fieldCount) {\n  this.name = DATA_ROW;\n  this.length = length;\n  this.fieldCount = fieldCount;\n  this.fields = [];\n};\n\n\n//extremely hot-path code\nConnection.prototype.parseD = function(buffer, length) {\n  var fieldCount = this.parseInt16(buffer);\n  var msg = new DataRowMessage(length, fieldCount);\n  for(var i = 0; i < fieldCount; i++) {\n    msg.fields.push(this._readValue(buffer));\n  }\n  return msg;\n};\n\n//extremely hot-path code\nConnection.prototype._readValue = function(buffer) {\n  var length = this.parseInt32(buffer);\n  if(length === -1) return null;\n  if(this._mode === TEXT_MODE) {\n    return this.readString(buffer, length);\n  }\n  return this.readBytes(buffer, length);\n};\n\n//parses error\nConnection.prototype.parseE = function(buffer, length) {\n  var fields = {};\n  var msg, item;\n  var input = new Message('error', length);\n  var fieldType = this.readString(buffer, 1);\n  while(fieldType != '\\0') {\n    fields[fieldType] = this.parseCString(buffer);\n    fieldType = this.readString(buffer, 1);\n  }\n  if(input.name === 'error') {\n    // the msg is an Error instance\n    msg = new Error(fields.M);\n    for (item in input) {\n      // copy input properties to the error\n      if(input.hasOwnProperty(item)) {\n        msg[item] = input[item];\n      }\n    }\n  } else {\n    // the msg is an object literal\n    msg = input;\n    msg.message = fields.M;\n  }\n  msg.severity = fields.S;\n  msg.code = fields.C;\n  msg.detail = fields.D;\n  msg.hint = fields.H;\n  msg.position = fields.P;\n  msg.internalPosition = fields.p;\n  msg.internalQuery = fields.q;\n  msg.where = fields.W;\n  msg.file = fields.F;\n  msg.line = fields.L;\n  msg.routine = fields.R;\n  return msg;\n};\n\n//same thing, different name\nConnection.prototype.parseN = function(buffer, length) {\n  var msg = this.parseE(buffer, length);\n  msg.name = 'notice';\n  return msg;\n};\n\nConnection.prototype.parseA = function(buffer, length) {\n  var msg = new Message('notification', length);\n  msg.processId = this.parseInt32(buffer);\n  msg.channel = this.parseCString(buffer);\n  msg.payload = this.parseCString(buffer);\n  return msg;\n};\n\nConnection.prototype.parseG = function (buffer, length) {\n  var msg = new Message('copyInResponse', length);\n  return this.parseGH(buffer, msg);\n};\n\nConnection.prototype.parseH = function(buffer, length) {\n  var msg = new Message('copyOutResponse', length);\n  return this.parseGH(buffer, msg);\n};\n\nConnection.prototype.parseGH = function (buffer, msg) {\n  var isBinary = buffer[this.offset] !== 0;\n  this.offset++;\n  msg.binary = isBinary;\n  var columnCount = this.parseInt16(buffer);\n  msg.columnTypes = [];\n  for(var i = 0; i<columnCount; i++) {\n    msg.columnTypes.push(this.parseInt16(buffer));\n  }\n  return msg;\n};\n\nConnection.prototype.parsed = function (buffer, length) {\n  var msg = new Message('copyData', length);\n  msg.chunk = this.readBytes(buffer, msg.length - 4);\n  return msg;\n};\n\nConnection.prototype.parseInt32 = function(buffer) {\n  var value = buffer.readInt32BE(this.offset, true);\n  this.offset += 4;\n  return value;\n};\n\nConnection.prototype.parseInt16 = function(buffer) {\n  var value = buffer.readInt16BE(this.offset, true);\n  this.offset += 2;\n  return value;\n};\n\nConnection.prototype.readString = function(buffer, length) {\n  return buffer.toString(this.encoding, this.offset, (this.offset += length));\n};\n\nConnection.prototype.readBytes = function(buffer, length) {\n  return buffer.slice(this.offset, this.offset += length);\n};\n\nConnection.prototype.parseCString = function(buffer) {\n  var start = this.offset;\n  while(buffer[this.offset++] !== 0) { }\n  return buffer.toString(this.encoding, start, this.offset - 1);\n};\n//end parsing methods\nmodule.exports = Connection;\n","/home/travis/build/npmtest/node-npmtest-pg.js/node_modules/pg.js/lib/pool.js":"var EventEmitter = require('events').EventEmitter;\n\nvar defaults = require(__dirname + '/defaults');\nvar genericPool = require('generic-pool');\n\nvar pools = {\n  //dictionary of all key:pool pairs\n  all: {},\n  //reference to the client constructor - can override in tests or for require('pg').native\n  Client: require(__dirname + '/client'),\n  getOrCreate: function(clientConfig) {\n    clientConfig = clientConfig || {};\n    var name = JSON.stringify(clientConfig);\n    var pool = pools.all[name];\n    if(pool) {\n      return pool;\n    }\n    pool = genericPool.Pool({\n      name: name,\n      max: clientConfig.poolSize || defaults.poolSize,\n      idleTimeoutMillis: clientConfig.poolIdleTimeout || defaults.poolIdleTimeout,\n      reapIntervalMillis: clientConfig.reapIntervalMillis || defaults.reapIntervalMillis,\n      log: clientConfig.poolLog || defaults.poolLog,\n      create: function(cb) {\n        var client = new pools.Client(clientConfig);\n        client.connect(function(err) {\n          if(err) return cb(err, null);\n\n          //handle connected client background errors by emitting event\n          //via the pg object and then removing errored client from the pool\n          client.on('error', function(e) {\n            pool.emit('error', e, client);\n\n            // If the client is already being destroyed, the error\n            // occurred during stream ending. Do not attempt to destroy\n            // the client again.\n            if (!client._destroying) {\n              pool.destroy(client);\n            }\n          });\n\n          // Remove connection from pool on disconnect\n          client.on('end', function(e) {\n            // Do not enter infinite loop between pool.destroy\n            // and client 'end' event...\n            if ( ! client._destroying ) {\n              pool.destroy(client);\n            }\n          });\n          client.poolCount = 0;\n          return cb(null, client);\n        });\n      },\n      destroy: function(client) {\n        client._destroying = true;\n        client.poolCount = undefined;\n        client.end();\n      }\n    });\n    pools.all[name] = pool;\n    //mixin EventEmitter to pool\n    EventEmitter.call(pool);\n    for(var key in EventEmitter.prototype) {\n      if(EventEmitter.prototype.hasOwnProperty(key)) {\n        pool[key] = EventEmitter.prototype[key];\n      }\n    }\n    //monkey-patch with connect method\n    pool.connect = function(cb) {\n      var domain = process.domain;\n      pool.acquire(function(err, client) {\n        if(domain) {\n          cb = domain.bind(cb);\n        }\n        if(err)  return cb(err, null, function() {/*NOOP*/});\n        client.poolCount++;\n        cb(null, client, function(err) {\n          if(err) {\n            pool.destroy(client);\n          } else {\n            pool.release(client);\n          }\n        });\n      });\n    };\n    return pool;\n  }\n};\n\nmodule.exports = pools;\n","/home/travis/build/npmtest/node-npmtest-pg.js/node_modules/pg.js/lib/native/index.js":"var Native = require('pg-native');\nvar TypeOverrides = require('../type-overrides');\nvar semver = require('semver');\nvar pkg = require('../../package.json');\nvar assert = require('assert');\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('util');\nvar ConnectionParameters = require(__dirname + '/../connection-parameters');\n\nvar msg = 'Version >= ' + pkg.minNativeVersion + ' of pg-native required.';\nassert(semver.gte(Native.version, pkg.minNativeVersion), msg);\n\nvar NativeQuery = require('./query');\n\nvar Client = module.exports = function(config) {\n  EventEmitter.call(this);\n  config = config || {};\n\n  this._types = new TypeOverrides(config.types);\n\n  this.native = new Native({\n    types: this._types\n  });\n\n  this._queryQueue = [];\n  this._connected = false;\n\n  //keep these on the object for legacy reasons\n  //for the time being. TODO: deprecate all this jazz\n  var cp = this.connectionParameters = new ConnectionParameters(config);\n  this.user = cp.user;\n  this.password = cp.password;\n  this.database = cp.database;\n  this.host = cp.host;\n  this.port = cp.port;\n\n  //a hash to hold named queries\n  this.namedQueries = {};\n};\n\nutil.inherits(Client, EventEmitter);\n\n//connect to the backend\n//pass an optional callback to be called once connected\n//or with an error if there was a connection error\n//if no callback is passed and there is a connection error\n//the client will emit an error event.\nClient.prototype.connect = function(cb) {\n  var self = this;\n\n  var onError = function(err) {\n    if(cb) return cb(err);\n    return self.emit('error', err);\n  };\n\n  this.connectionParameters.getLibpqConnectionString(function(err, conString) {\n    if(err) return onError(err);\n    self.native.connect(conString, function(err) {\n      if(err) return onError(err);\n\n      //set internal states to connected\n      self._connected = true;\n\n      //handle connection errors from the native layer\n      self.native.on('error', function(err) {\n        //error will be handled by active query\n        if(self._activeQuery && self._activeQuery.state != 'end') {\n          return;\n        }\n        self.emit('error', err);\n      });\n\n      self.native.on('notification', function(msg) {\n        self.emit('notification', {\n          channel: msg.relname,\n          payload: msg.extra\n        });\n      });\n\n      //signal we are connected now\n      self.emit('connect');\n      self._pulseQueryQueue(true);\n\n      //possibly call the optional callback\n      if(cb) cb();\n    });\n  });\n};\n\n//send a query to the server\n//this method is highly overloaded to take\n//1) string query, optional array of parameters, optional function callback\n//2) object query with {\n//    string query\n//    optional array values,\n//    optional function callback instead of as a separate parameter\n//    optional string name to name & cache the query plan\n//    optional string rowMode = 'array' for an array of results\n//  }\nClient.prototype.query = function(config, values, callback) {\n  var query = new NativeQuery(this.native);\n\n  //support query('text', ...) style calls\n  if(typeof config == 'string') {\n    query.text = config;\n  }\n\n  //support passing everything in via a config object\n  if(typeof config == 'object') {\n    query.text = config.text;\n    query.values = config.values;\n    query.name = config.name;\n    query.callback = config.callback;\n    query._arrayMode = config.rowMode == 'array';\n  }\n\n  //support query({...}, function() {}) style calls\n  //& support query(..., ['values'], ...) style calls\n  if(typeof values == 'function') {\n    query.callback = values;\n  }\n  else if(util.isArray(values)) {\n    query.values = values;\n  }\n  if(typeof callback == 'function') {\n    query.callback = callback;\n  }\n\n  this._queryQueue.push(query);\n  this._pulseQueryQueue();\n  return query;\n};\n\n//disconnect from the backend server\nClient.prototype.end = function(cb) {\n  var self = this;\n  if(!this._connected) {\n    this.once('connect', this.end.bind(this, cb));\n  }\n  this.native.end(function() {\n    //send an error to the active query\n    if(self._hasActiveQuery()) {\n      var msg = 'Connection terminated';\n      self._queryQueue.length = 0;\n      self._activeQuery.handleError(new Error(msg));\n    }\n    self.emit('end');\n    if(cb) cb();\n  });\n};\n\nClient.prototype._hasActiveQuery = function() {\n  return this._activeQuery && this._activeQuery.state != 'error' && this._activeQuery.state != 'end';\n};\n\nClient.prototype._pulseQueryQueue = function(initialConnection) {\n  if(!this._connected) {\n    return;\n  }\n  if(this._hasActiveQuery()) {\n    return;\n  }\n  var query = this._queryQueue.shift();\n  if(!query) {\n    if(!initialConnection) {\n      this.emit('drain');\n    }\n    return;\n  }\n  this._activeQuery = query;\n  query.submit(this);\n  var self = this;\n  query.once('_done', function() {\n    self._pulseQueryQueue();\n  });\n};\n\n//attempt to cancel an in-progress query\nClient.prototype.cancel = function(query) {\n  if(this._activeQuery == query) {\n    this.native.cancel(function() {});\n  } else if (this._queryQueue.indexOf(query) != -1) {\n    this._queryQueue.splice(this._queryQueue.indexOf(query), 1);\n  }\n};\n\nClient.prototype.setTypeParser = function(oid, format, parseFn) {\n  return this._types.setTypeParser(oid, format, parseFn);\n};\n\nClient.prototype.getTypeParser = function(oid, format) {\n  return this._types.getTypeParser(oid, format);\n};\n"}